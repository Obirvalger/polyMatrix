% \documentclass[a4paper, 14pt]{extarticle}
\documentclass[bibliography=totoc, a4paper, 14pt]{extarticle}
\usepackage{setspace}
\usepackage {indentfirst}
\setstretch{1.3}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[nottoc,notlot,notlof]{tocbibind}
\usepackage{icomma}
\let\stdsection\section
\renewcommand\section{\newpage\stdsection}
\addto\captionsrussian{% Replace "english" with the language you use
  \renewcommand{\contentsname}%
    {Оглавление}%
}
\hypersetup{
    colorlinks,
    allcolors=blue
}
\usepackage{longtable, moreverb}
\usepackage{ amssymb, latexsym, amsmath, amsthm}
\newtheorem{myth}{Теорема}
\newtheorem{mylm}{Лемма}
\newtheorem*{myco}{Следствие}
\usepackage{verbatim}
\newcommand{\rol} {\textrm{rol}}
\newcommand{\pphi}[1] {P^{\delta}(\varphi_{#1})}
\textwidth=17cm       % Эти строки нужны для того,
\textheight=21cm      % чтобы равенства уместились
\oddsidemargin=0cm    % на странице

\sloppy
% \fussy

\xdef\LastDeclaredEncoding{T2A}

\begin{document}
\setcounter{page}{3}
\setcounter{secnumdepth}{-1}

\tableofcontents

\section{Введение}
Одним из стандартных способов задания функций k\nobreakdash-значной логики являются поляризованные
полиномиальные формы (ППФ), которые также называются обобщенными формами Рида-Мюллера, или
каноническими поляризованными полиномами. В ППФ каждая переменная имеет определенную поляризацию.
Длиной полиномиальной формы называется число попарно различных слагаемых в ней. Длиной функции $f$
в классе ППФ называется наименьшая длина среди длин всех поляризованных полиномиальных форм,
реализующих $f$. Функция Шеннона $L^K_k(n)$ длины определяется как наибольшая длина среди всех
функций $k$\nobreakdash-значной логики в классе $K$ от~$n$~переменных, если $K$ опущено, то
подразумевается класс ППФ. Практическое применение ППФ нашли при построении программируемых
логических матриц (ПЛМ)~\cite{ue04, sb90}, сложность ПЛМ напрямую зависит от длины ППФ, по которой
она построена. Поэтому в ряде работ исследуется сложность ППФ различных функций
\cite{sv93,pn95,ss02,kk05,sd08,mn12,sm09}.

В 1993  В.\,П.\,Супрун~\cite{sv93} получил первые оценки функции Шеннона для функций алгебры логики :
$$
L_2(n) \geqslant C_n^{[\frac{n}{2}]},
$$
$$
L_2(n) < 3 \cdot 2^{n-1},
$$
где [$a$] обозначает целую часть $a$.

Точное значение функции Шеннона для функций алгебры логики в 1995\,г. было
найдено Н.\,А.\,Перязевым~\cite{pn95} :
$$
L_2(n) = \left[\frac{2^{n+1}}{3}\right].
$$

Функции $k$\nobreakdash-значных логик являются естественным обобщением функций алгебры логики.
Для функций $k$\nobreakdash-значной логики верхняя оценка функции Шеннона была получена в 2002\,г. С.\,Н.\,Селезневой~\cite{ss02} :
$$
L_k(n) < \frac{k(k-1)}{k(k-1)+1}k^n.
$$

При построении ПЛМ рассматривают и другие полиномиальные формы. Например класс обобщенных полиномиальных форм.
В классе обобщенных полиномиальных форм, в отличие от класса поляризованных полиномиальных форм, переменные могут иметь
различную поляризацию в разных слагаемых. В статье К.\,Д.\,Кириченко~\cite{kk05}, опубликованной в 2005\,г., получена верхняя оценка
функции Шеннона в классе обобщенных полиномиальных форм функций алгебры логики :
$$
L^{\text{О.П.}}_2(n) \leqslant \frac{2 ^ {n + 1}(\log_2n+1)}{n}.
$$

Верхняя оценка функции Шеннона в классе обобщенных полиномиальных форм функций k\nobreakdash-значной логики была получена
С.\,Н.\,Селезневой и А.\,Б.\,Дайняком в 2008\,г.~\cite{sd08}:
$$
L^{\text{О.П.}}_k(n) \lesssim 2\cdot\frac{k ^ n}{n}\cdot \ln n \text{ при } n \rightarrow \infty.
$$

В 2012\,г. Н.\,К.\,Маркеловым была получена нижняя оценка функции Шеннона для функции трехзначной логики в классе
поляризованных полиномов~\cite{mn12}:
$$
L_3(n) \geqslant \left[\frac{3}{4}3^n\right].
$$

\section{Основные определения}

Пусть $k \geqslant 2$ -- натуральное число, $E_k = \{0, 1, \dots, k - 1\}$. Весом набора
$\alpha = (a_1, \dots, a_n ) \in E_k^n$ назовем число $|\alpha| = \sum\limits_{i=1}^n a_i$.
Моном $\prod\limits_{a_i\neq0}x_i^{a_i}$ назовем соответствующим набору $\alpha =
(a_1, \dots, a_n ) \in E_k^n$ и обозначим через $K_{\alpha}$. По определению положим, что константа
1 соответствует набору из всех нулей. Функцией $k$\nobreakdash-значной логики называется
отображение $f^{(n)} : E_k^n \rightarrow E_k$, $n = 0, 1, \dots$.
Множество всех функций $k$-значной логики обозначим через $P_k$ , множество всех функций
$k$-значной логики, зависящих от переменных $x_1, \dots, x_n$ , обозначим через $P_k^n$.
Функция $j_i(x) = \begin{cases} 1, \text{ если } x = i; \\
                                0, \text{ если } x \neq i. \end{cases}$
% При простом $k$ $j_i(x)$ может быть представлена ввиде $j_i(x) = 1-(x-i)^{k-1}$.

Если $k$ -- простое число, то каждая функция $k$\nobreakdash-значной логики $f(x_1 , \dots , x_n)$
может быть однозначно задана формулой вида

$$ f(x_1, \dots, x_n) = \sum_{\alpha \in E_k^n:c_f(\alpha) \neq 0}c_f(\alpha)K_\alpha \; ,$$
где $c_f(\alpha) \in E_k$ -- коэффициенты, $\alpha \in E_k$, и операции сложения и умножения
рассматриваются по модулю $k$. Это представление функций $k$\nobreakdash-значной
логики называется ее полиномом по модулю $k$. При простых $k$ однозначно
определенный полином по модулю k для функции $k$\nobreakdash-значной логики $f$ будем
обозначать через $P(f)$.

Определим поляризованные полиномиальные формы по модулю $k$. Поляризованной переменной $x_i$ с поляризацией $d$,
$d \in E_k$ , назовем выражение вида $(x_i + d)$. Поляризованным мономом по вектору поляризации $\delta$,
$\delta = (d_1, \dots, d_n) \in E_k^n$, назовем произведение вида $(x_{i_1} + d_{i_1} )^{m_1}\cdots(x_{i_r} + d_{i_r})^{m_r}$,
где $1 \leqslant i_1 < \ldots < i_r \leqslant n$, и $1 \leqslant m_1 , \dots , m_r \leqslant k - 1$. Обычный моном является
мономом, поляризованным по вектору $\tilde{0} = (0, \dots, 0) \in E_k^n $.

Выражение вида $\sum\limits_{i=1}^lc_i \cdot K_i$, где $c_i \in E_k\setminus\{0\}$ -- коэффициенты, $K_i$ -- попарно
различные мономы, поляризованные по вектору $\delta = (d_1, \dots, d_n) \in E_k^n$, $i = 1, \dots , l$, назовем
поляризованной полиномиальной нормальной формой (ППФ) по вектору поляризации $\delta$. Мы будем считать, что константа 0
является ППФ по произвольному вектору поляризации. Заметим, что при простых $k$ для каждого вектора поляризации каждую функцию
$k$\nobreakdash-значной логики можно однозначно представить ППФ по этому вектору поляризации \cite{ss02}. При простых $k$
однозначно определенную ППФ по вектору поляризации $\delta \in E_k^n$ для функции
$f \in P_k^n$ будем обозначать через $P^{\delta}(f)$.

Длиной $l(p)$ ППФ $p$ назовем число попарно различных слагаемых в этой
ППФ. Положим, что $l(0) = 0$. При простых $k$ длиной функции $k$\nobreakdash-значной
логики в классе ППФ называется величина $l^{\text{ППФ}}(f) = \min\limits_{\delta \in E_k^n}l(P^{\delta}(f))$.

Функция $k$\nobreakdash-значной логики $f(x_1 ,\dots , x_n)$ называется симметрической, если
$$f(\pi(x_1), \dots, \pi(x_n)) = f(x_1, \dots, x_n)$$
для произвольной перестановки $\pi$ на множестве переменных $\{x_1 , \dots , x_n \}$.
Множество всех симметрических функций $k$\nobreakdash-значной логики обозначим через $S_k$.
Симметрическая функция $f(x_1, \dots, x_n)$ называется периодической c
периодом $\tau = (\tau_0 \tau_1 \dots \tau_{T-1}) \in E_k^T$ , если $f(\alpha) = \tau_j$ при $|\alpha| = j \pmod T$
для каждого набора $\alpha \in E_k^n$. При этом число $T$ называется длиной периода. Периодическую функцию
$k$\nobreakdash-значной логики $f(x_1 , \dots , x_n)$ с периодом $\tau = (\tau_0 \tau_1 \dots \tau_{T-1}) \in E_k^T$
будем обозначать через $f^{(n)}_{(\tau_0 \tau_1 \dots \tau_{T-1})}$. Понятно, что
такое обозначение полностью определяет эту функцию.

Введем функцию $\rol_i(\alpha) \in E_k^n \times E_k \rightarrow E_k^n$, производящую циклический сдвиг вектора $\alpha$
влево. Пусть $\alpha = (a_1, \dots, a_n)$, тогда $\rol_i(\alpha) = (a_{(1+i)\mod k}, \dots, a_{(n+i)\mod k})$.

В \cite{sm09} дается описание быстрого алгоритма построения поляризованного полинома по заданному вектору
функции и поляризации $d$. Данный алгоритм можно использовать для получения периодов, участвующих в разложении
периодической симметрической функции $f^{(n+1)}$ с периодом $\tau$. 
$$A_d \cdot F = \begin{pmatrix}
\tau_0 \\
\tau_1 \\
\vdots \\
\tau_{k-1} \\
\end{pmatrix} \text{, где}
$$

$$f_{\tau}^{(n+1)} = f_{\tau_{k-1}}^{(n)}(x_{n+1}+d)^{k-1} + f_{\tau_{k-2}}^{(n)}(x_{n+1}+d)^{k-2} + \ldots + f_{\tau_{0}}^{(n)}$$

$$
A = \begin{pmatrix}
1      & 0      & 0                  & \ldots & 0                      \\
0      & k-1    & -(2^{k-2}) \bmod k & \ldots & -((k-1)^{k-2}) \bmod k \\
\vdots & \vdots &  \vdots            & \ddots & \vdots                 \\
k-1    & k-1    & k-1                & \ldots & k-1                    \\
\end{pmatrix}
$$

$A_d$ получается из матрицы $A$ циклическим сдвигом столбцов $A$ влево на $d$ столбцов или построчным применением
функции $rol_d$ к матрице $A$.

$$
F = \begin{pmatrix}
rol_0(\tau)     \\
rol_1(\tau)     \\
\vdots          \\
rol_{k-1}(\tau) \\
\end{pmatrix}
$$

Например в трехзначной логике для функции с периодом $[1,1,2,2]$ получим
$$
\begin{pmatrix}
1 & 0 & 0 \\
0 & 2 & 1 \\
2 & 2 & 2 \\
\end{pmatrix}
\cdot
\begin{pmatrix}
1 & 1 & 2 & 2 \\
1 & 2 & 2 & 1 \\
2 & 2 & 1 & 1 \\
\end{pmatrix}
=
\begin{pmatrix}
1 & 1 & 2 & 2 \\
1 & 0 & 2 & 0 \\
2 & 1 & 1 & 2 \\
\end{pmatrix}
$$

Пусть $T \geqslant  1$, $s \geqslant 1$, $\Pi = \{\tau_1, \dots, \tau_s | \tau_i \in E_k^T\}$,
$A_{\Pi} = \{f_{\tau}^{(n)}|\tau \in \Pi, n \geqslant 1\}$. Класс $A_{\Pi}$ называется вырожденным,
если для любого $\tau \in \Pi$ верно, что $l(f_{\tau}^{(n)}) = \bar{o}(k^n)$, при $n\rightarrow
\infty$.

Для любого простого $k$ и любой симметрической периодической функции $f(x_1, \dots, x_n)$ $k$\nobreakdash-значной логики с
периодом $\tau = (\tau_0 \tau_1 \dots \tau_{T-1}) \in E_k^T$ и для любого $d$ из $E_k$. Верно следующее разложение:
$$f^{(n+1)} = f_{k-1}^{(n)}\cdot(x_{n+1}+d)^{k-1} + f_{k-2}^{(n)}\cdot(x_{n+1}+d)^{k-2} + \ldots + f^{(n)}_0\text{, где}$$
$f_{k-1}^{(n)}, f_{k-2}^{(n)}, \ldots, f_0^{(n)}$ -- функции зависящие от переменных $x_1, \ldots, x_n$. Для различных поляризации $d$
это могут быть различные функции.
В данном разложении будут получаться только симметрические периодические функции с периодом такой же длины.

Все функции, присутствующие в разложении функции $f$, хотябы с какой-либо поляризацией $d$ назовем -- порожденными $f$.
Семейство функций, порожденных данной симметрической периодической функцией $f$ получается по следующему алгоритму:
\begin{enumerate}
\item добавляем в множество $F$ функцию $f$;
\item для всех, еще не рассмотренных функций из $F$, добавляем порожденные ими функции в $F$, а сами функции помечаем, как рассмотренные;
\item повторяем второй шаг, пока не рассмотрим все функции.
\end{enumerate}
Этот агоритм завершается, так как число различных периодов заданной длины конечно.

\section{Постановка задачи}

\section{Результаты}
\subsection{Теоремы}
\begin{myth} Если в семействе $F$, порожденном функцией $f$ нет функции $\tilde{0}$, то класс функций $F$ будет невырожденным.
\end{myth}

\begin{myth} Все симметрические периодические функции пятизначной логики с периодами длины 3, отличными от $[0,0,0], [1,1,1],
[2,2,2], [3,3,3], [4,4,4]$ порождают невырожденные семейства функций.
\end{myth}

\subsection{Пример}
Рассмотрим функцию $f=f_{(0,1,4)}$, эта функция порождает cемейство функций $F$:
$$
f=f_{(0,1,4)}, g=f_{(1,0,4)}, h=f_{(1,1,3)}, p=f_{(1,2,2)}, s=f_{(1,3,1)}, t=f_{(1,4,0)}
$$

Для этих функций верны следующие разложения.

$f=f_{(0,1,4)}$
$$
\begin{array}{l}
f_{n+1} = x_{n+1}^43f_{n} + x_{n+1}^3t_{n} + x_{n+1}^23p_{n} + x_{n+1}2g_{n} + f_{n} \\
f_{n+1} = (x_{n+1}+1)^43f_{n} + (x_{n+1}+1)^3p_{n} + (x_{n+1}+1)^22f_{n} + (x_{n+1}+1)4p_{n} + f_{n} \\
f_{n+1} = (x_{n+1}+2)^43f_{n} + (x_{n+1}+2)^3g_{n} + (x_{n+1}+2)^22p_{n} + (x_{n+1}+2)2t_{n} + f_{n} \\
f_{n+1} = (x_{n+1}+3)^43f_{n} + (x_{n+1}+3)^3s_{n} + (x_{n+1}+3)^24s_{n} + (x_{n+1}+3)s_{n} + 4g_{n} \\
f_{n+1} = (x_{n+1}+4)^43f_{n} + (x_{n+1}+4)^3h_{n} + (x_{n+1}+4)^2h_{n} + (x_{n+1}+4)h_{n} + t_{n} \\
\end{array}
$$

$g=f_{(1,0,4)}$
$$
\begin{array}{l}
g_{n+1} = x_{n+1}^43g_{n} + x_{n+1}^34f_{n} + x_{n+1}^24s_{n} + x_{n+1}2t_{n} + g_{n} \\
g_{n+1} = (x_{n+1}+1)^43g_{n} + (x_{n+1}+1)^33s_{n} + (x_{n+1}+1)^22g_{n} + (x_{n+1}+1)2s_{n} + g_{n} \\
g_{n+1} = (x_{n+1}+2)^43g_{n} + (x_{n+1}+2)^3t_{n} + (x_{n+1}+2)^2s_{n} + (x_{n+1}+2)3f_{n} + g_{n} \\
g_{n+1} = (x_{n+1}+3)^43g_{n} + (x_{n+1}+3)^34h_{n} + (x_{n+1}+3)^2h_{n} + (x_{n+1}+3)4h_{n} + 4t_{n} \\
g_{n+1} = (x_{n+1}+4)^43g_{n} + (x_{n+1}+4)^32p_{n} + (x_{n+1}+4)^22p_{n} + (x_{n+1}+4)2p_{n} + 4f_{n} \\
\end{array}
$$

$h=f_{(1,1,3)}$
$$
\begin{array}{l}
h_{n+1} = x_{n+1}^43h_{n} + x_{n+1}^3s_{n} + x_{n+1}^22t_{n} + x_{n+1}4p_{n} + h_{n} \\
h_{n+1} = (x_{n+1}+1)^43h_{n} + (x_{n+1}+1)^34t_{n} + (x_{n+1}+1)^22h_{n} + (x_{n+1}+1)t_{n} + h_{n} \\
h_{n+1} = (x_{n+1}+2)^43h_{n} + (x_{n+1}+2)^32p_{n} + (x_{n+1}+2)^23t_{n} + (x_{n+1}+2)2s_{n} + h_{n} \\
h_{n+1} = (x_{n+1}+3)^43h_{n} + (x_{n+1}+3)^32f_{n} + (x_{n+1}+3)^23f_{n} + (x_{n+1}+3)2f_{n} + 3p_{n} \\
h_{n+1} = (x_{n+1}+4)^43h_{n} + (x_{n+1}+4)^33g_{n} + (x_{n+1}+4)^23g_{n} + (x_{n+1}+4)3g_{n} + s_{n} \\
\end{array}
$$

$p=f_{(1,2,2)}$
$$
\begin{array}{l}
p_{n+1} = x_{n+1}^43p_{n} + x_{n+1}^32h_{n} + x_{n+1}^24f_{n} + x_{n+1}s_{n} + p_{n} \\
p_{n+1} = (x_{n+1}+1)^43p_{n} + (x_{n+1}+1)^33f_{n} + (x_{n+1}+1)^22p_{n} + (x_{n+1}+1)2f_{n} + p_{n} \\
p_{n+1} = (x_{n+1}+2)^43p_{n} + (x_{n+1}+2)^33s_{n} + (x_{n+1}+2)^2f_{n} + (x_{n+1}+2)4h_{n} + p_{n} \\
p_{n+1} = (x_{n+1}+3)^43p_{n} + (x_{n+1}+3)^3g_{n} + (x_{n+1}+3)^24g_{n} + (x_{n+1}+3)g_{n} + 2s_{n} \\
p_{n+1} = (x_{n+1}+4)^43p_{n} + (x_{n+1}+4)^34t_{n} + (x_{n+1}+4)^24t_{n} + (x_{n+1}+4)4t_{n} + 2h_{n} \\
\end{array}
$$

$s=f_{(1,3,1)}$
$$
\begin{array}{l}
s_{n+1} = x_{n+1}^43s_{n} + x_{n+1}^33p_{n} + x_{n+1}^23g_{n} + x_{n+1}3h_{n} + s_{n} \\
s_{n+1} = (x_{n+1}+1)^43s_{n} + (x_{n+1}+1)^3g_{n} + (x_{n+1}+1)^22s_{n} + (x_{n+1}+1)4g_{n} + s_{n} \\
s_{n+1} = (x_{n+1}+2)^43s_{n} + (x_{n+1}+2)^34h_{n} + (x_{n+1}+2)^22g_{n} + (x_{n+1}+2)p_{n} + s_{n} \\
s_{n+1} = (x_{n+1}+3)^43s_{n} + (x_{n+1}+3)^32t_{n} + (x_{n+1}+3)^23t_{n} + (x_{n+1}+3)2t_{n} + h_{n} \\
s_{n+1} = (x_{n+1}+4)^43s_{n} + (x_{n+1}+4)^32f_{n} + (x_{n+1}+4)^22f_{n} + (x_{n+1}+4)2f_{n} + 3p_{n} \\
\end{array}
$$

$t=f_{(1,4,0)}$
$$
\begin{array}{l}
t_{n+1} = x_{n+1}^43t_{n} + x_{n+1}^34g_{n} + x_{n+1}^2h_{n} + x_{n+1}3f_{n} + t_{n} \\
t_{n+1} = (x_{n+1}+1)^43t_{n} + (x_{n+1}+1)^32h_{n} + (x_{n+1}+1)^22t_{n} + (x_{n+1}+1)3h_{n} + t_{n} \\
t_{n+1} = (x_{n+1}+2)^43t_{n} + (x_{n+1}+2)^34f_{n} + (x_{n+1}+2)^24h_{n} + (x_{n+1}+2)3g_{n} + t_{n} \\
t_{n+1} = (x_{n+1}+3)^43t_{n} + (x_{n+1}+3)^33p_{n} + (x_{n+1}+3)^22p_{n} + (x_{n+1}+3)3p_{n} + f_{n} \\
t_{n+1} = (x_{n+1}+4)^43t_{n} + (x_{n+1}+4)^3s_{n} + (x_{n+1}+4)^2s_{n} + (x_{n+1}+4)s_{n} + 4g_{n} \\
\end{array}
$$

Функции одной переменной.

$f=f_{(0,1,4)}$
$$
\begin{array}{l}
f_1 = 3x + 2x^2 + 2x^3 + 4x^4 \\
f_1 = 1 + 4(x+1) + (x+1)^3 + 4(x+1)^4 \\
f_1 = (x+2) + (x+2)^2 + 4(x+2)^4 \\
f_1 = 4 + 3(x+3) + 4(x+3)^3 + 4(x+3)^4 \\
f_1 = 1 + 4(x+4) + 2(x+4)^2 + 3(x+4)^3 + 4(x+4)^4 \\
\end{array}
$$

$g=f_{(1,0,4)}$
$$
\begin{array}{l}
g_1 = 1 + x + 4x^3 + 4x^4 \\
g_1 = 2(x+1) + 2(x+1)^2 + 3(x+1)^3 + 4(x+1)^4 \\
g_1 = 1 + (x+2) + 2(x+2)^2 + 2(x+2)^3 + 4(x+2)^4 \\
g_1 = 4 + 2(x+3) + (x+3)^3 + 4(x+3)^4 \\
g_1 = 4(x+4) + (x+4)^2 + 4(x+4)^4 \\
\end{array}
$$

$h=f_{(1,1,3)}$
$$
\begin{array}{l}
h_1 = 1 + 4x + 2x^2 + x^3 + 3x^4 \\
h_1 = 1 + (x+1) + 2(x+1)^2 + 4(x+1)^3 + 3(x+1)^4 \\
h_1 = 1 + 2(x+2) + 3(x+2)^2 + 2(x+2)^3 + 3(x+2)^4 \\
h_1 = 3 + 3(x+3)^4 \\
h_1 = 1 + 3(x+4) + 3(x+4)^2 + 3(x+4)^3 + 3(x+4)^4 \\
\end{array}
$$

$p=f_{(1,2,2)}$
$$
\begin{array}{l}
p_1 = 1 + 2x + 4x^2 + 3x^3 + 2x^4 \\
p_1 = 2 + 2(x+1)^2 + 2(x+1)^4 \\
p_1 = 1 + 3(x+2) + 4(x+2)^2 + 2(x+2)^3 + 2(x+2)^4 \\
p_1 = 2 + 3(x+3) + 4(x+3)^3 + 2(x+3)^4 \\
p_1 = 2 + 2(x+4) + (x+4)^3 + 2(x+4)^4 \\
\end{array}
$$

$s=f_{(1,3,1)}$
$$
\begin{array}{l}
s_1 = 1 + x^2 + x^4 \\
s_1 = 3 + 4(x+1) + 2(x+1)^2 + (x+1)^3 + (x+1)^4 \\
s_1 = 1 + 4(x+2) + 2(x+2)^3 + (x+2)^4 \\
s_1 = 1 + (x+3) + 3(x+3)^3 + (x+3)^4 \\
s_1 = 3 + (x+4) + 2(x+4)^2 + 4(x+4)^3 + (x+4)^4 \\
\end{array}
$$

$t=f_{(1,4,0)}$
$$
\begin{array}{l}
t_1 = 1 + 3x + 3x^2 + 2x^3 \\
t_1 = 4 + 3(x+1) + 2(x+1)^2 + 2(x+1)^3 \\
t_1 = 1 + (x+2)^2 + 2(x+2)^3 \\
t_1 = 4(x+3) + 2(x+3)^3 \\
t_1 = 4 + 4(x+4)^2 + 2(x+4)^3 \\
\end{array}
$$

В следующей таблице содержатся длины функций одной переменной.

\begin{center}
\begin{tabular}{| l | l | l | l | l | l |}
\hline
 & 0 & 1 & 2 & 3 & 4 \\
\hline
$f_{1}$ & 4 & 4 & 3 & 4 & 5 \\
\hline
$g_{1}$ & 4 & 4 & 5 & 4 & 3 \\
\hline
$h_{1}$ & 5 & 5 & 5 & 2 & 5 \\
\hline
$p_{1}$ & 5 & 3 & 5 & 4 & 4 \\
\hline
$s_{1}$ & 3 & 5 & 4 & 4 & 5 \\
\hline
$t_{1}$ & 4 & 4 & 3 & 2 & 3 \\
\hline
\end{tabular}
\end{center}

\begin{myth} Для любой функйии $f^n_{\tau} \in F$ верно:
$l(f^n_{\tau}) \geqslant \frac{2}{5}\cdot 5^n$.
\end{myth}
\begin{proof}
Длина полиномов всех функций одной переменной из $F$ при любой поляризации не меньше 2.
В разложении каждой функции из $F$ по любой поляризации присутствуют 5 функций из $F$.
\end{proof}

\section{Заключение}

\section{Приложение}

%\lstinputlisting[language=Haskell]{PolyMatrix.hs}

Сдесь приведен код основных функций, используемых в программе.
\begin{footnotesize}
\begin{verbatim}
k :: Int
k = 5

rol :: [a] -> Int -> [a]
rol xs i = let (l,r) = splitAt i xs in r ++ l

ror :: [a] -> Int -> [a]
ror xs i = let (l,r) = splitAt (length xs - i) xs in r ++ l

invert' k 1 = 1
invert' k p = (n * k + 1) `div` p
  where n = p - invert' p (k `mod` p)

invert = invert' k

allVectors n = sequence $ take (fromIntegral n) $ repeat [0..k-1]

allNormalVectors n = map (1:) $ allVectors (n-1)

normalize :: [Int] -> [Int]
normalize [] = error "Empty list"
normalize xs = normalize' xs xs where
  normalize' [] ys     = error "Zero list"
  normalize' (x:xs) ys | x == 0    = normalize' xs ys
                       | otherwise = map (\n -> n * invert x `mod` k) ys

reverseMatrix = fromLists . reverse . toLists

modkM = fmap (`mod` k)

a_ij = uncurry a_ij' where
    a_ij' :: Int -> Int -> Int
    a_ij' i j | i == 1 && j == 1 = 1
              | i == k         = (-1) `mod` k
              | i == 1 || j == 1 = 0
              | otherwise = (-(j-1)^((k-1-(i-1)) `mod` k)) `mod` k

a = matrix k k a_ij

aPolar d = fromLists $ Data.List.transpose $
  rol (Data.List.transpose $ toLists a) d

fromPeriod xs = fromLists $ map (rol xs) [0..k-1]

polarCoeffs d xs = reverse $ toLists $ modkM $ aPolar d * fromPeriod xs

allCoeffs xs = concatMap (\d -> polarCoeffs d xs) [0..k-1]

setSort :: Ord a => [a] -> [a]
setSort = compress . sort where
  compress []     = []
  compress (x:xs) = x : (compress $ dropWhile (== x) xs)

makeAllFamily ps = makeAllFamily' [normalize ps] $ setSort $
  map normalize $ allCoeffs ps where
  makeAllFamily' xss yss  | xss == yss = yss    
                          | otherwise  = makeAllFamily' (insert zs xss) zss where
                            zs  = normalize $ firstNotIn yss xss
                            zss = setSort $ yss ++ (map normalize $ allCoeffs zs)
  firstNotIn (y:ys) (x:xs) | y < x  = y
                           | y > x  = firstNotIn (y:ys) xs
                           | y == x = firstNotIn ys xs
  firstNotIn (y:ys) [] = y

singular [] = putStr ""
singular (x:xs) = do
  result <- try (evaluate (makeAllFamily x)) :: IO (Either SomeException [[Int]])
  case result of
    Left ex   -> putStrLn $  "Singular " ++ show x
    Right val -> putStrLn $ "Nonsingular " ++ show x ++ " " ++ (show $ length val)
  singular xs

\end{verbatim}
\end{footnotesize}

\makeatletter
\renewcommand*{\@biblabel}[1]{\hfill#1.}
\makeatother

\begin{singlespace}
\begin{thebibliography}{0}
\bibitem{ue04} Угрюмов~Е.\,П. Цифровая схемотехника. СПб.: БХВ-Петербург, 2004.
\bibitem{sb90} Sasao T., Besslich P. On the complexity of mod-2 sum PLA’s  // IEEE Trans.on Comput. 39. N 2. 1990. P.~262--266.
\bibitem{sv93} Супрун~В.\,П. Сложность булевых функций в классе канонических поляризованных полиномов // Дискретная математика. 5.
    \textnumero 2. 1993. С. 111--115.
\bibitem{pn95} Перязев Н.\,А. Сложность булевых функций в классе полиномиальных поляризованных~форм // Алгебра и логика. 34.
    \textnumero 3. 1995. С. 323--326.
\bibitem{ss02} Селезнева С.\,H. О сложности представления функций многозначных логик поляризованными полиномами. Дискретная
    математика. 14. \textnumero 2. 2002. С.~48--53.
\bibitem{kk05} Кириченко~К.\,Д. Верхняя оценка сложности полиномиальных нормальных форм булевых функций
    // Дискретная математика. 17. \textnumero 3. 2005. С. 80--88.
\bibitem{sd08} Селезнева С.\,Н. Дайняк А.\,Б. О сложности обобщенных полиномов k\nobreakdash-значных функций // Вестник Московского
    университета. Серия 15. Вычислительная математика и кибернетика. \textnumero 3. 2008. С. 34--39.
\bibitem{mn12} Маркелов Н.\,К. Нижняя оценка сложности функций трехзначной логики в классе поляризованных полиномов // Вестник
    Московского университета. Серия 15. Вычислительная математика и кибернетика. \textnumero 3. 2012. С. 40--45.
\bibitem{sm09} Селезнева С.\,H. Маркелов Н.\,К. Быстрый алгоритм построения векторов коэффициэнтов поляризованных полиномов
    k-значных функций // Ученые записки Казанского университета. Серия Физико-математические науки. 2009. 151.
    \textnumero 2 С.~147-151.
\end{thebibliography}

\end{singlespace}

\end{document}
